<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Display the CPU percentage  - Das Keyboard </title>
  <link rel="shortcut icon" href="/daskeyboard.github.io/images/favicon.png">

  <meta name="description" content="">
  <meta name="keywords" content=" ">
  
  <link rel="stylesheet" href="/daskeyboard.github.io/css/css-bootstrap/bootstrap.css">
  <link rel="stylesheet" href="/daskeyboard.github.io/css/main.css"> 
  
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Extended" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro%7CRoboto:500,400italic,300,400" rel="stylesheet">
  
  <link rel="canonical" href="https://daskeyboard.github.io/daskeyboard.github.io/script-examples/cpu-percentage/">
  <script src="https://www.gstatic.com/firebasejs/4.11.0/firebase.js"></script>
  <script>
    // Initialize Firebase
    var config = {
      apiKey: "AIzaSyCymDaJN7cjeIW8fHiHu-JyvtH5We-gamw",
      authDomain: "daskeyboard.github.io-fafc7.firebaseapp.com",
      databaseURL: "https://daskeyboard.github.io-fafc7.firebaseio.com",
      projectId: "daskeyboard.github.io-fafc7",
      storageBucket: "daskeyboard.github.io-fafc7.appspot.com",
      messagingSenderId: "946286108585"
    };
    firebase.initializeApp(config);
  </script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-67589403-1', 'auto');
    ga('send', 'pageview');
  </script>

  <meta name="google-site-verification" content="HFqxhSbf9YA_0rBglNLzDiWnrHiK_w4cqDh2YD2GEY4" />
</head>

    
    
    

    <div id="overlay-under-drawer"><!-- for the drawer on narrow screens --></div>
    <header class="site-header">
  <div class="container-fluid header-contents">
    <div class="row">
      <div class="col-md-12">
        <i class="fa fa-bars" id="sidebar-toggle-button" aria-hidden="true" style="display:none"></i>
        <img src="/daskeyboard.github.io/images/icon.png" alt="Das Keyboard Logo" width="24" height="32" style="vertical-align:middle">

        <a class="site-title" href="/daskeyboard.github.io/">Das Keyboard</a>

        <nav class="site-nav">
          <a href="#" class="menu-icon">
            <i class="material-icons-extended">more_vert</i>
          </a>
          <div class="trigger">
            <a class="page-link" href="/daskeyboard.github.io/docs/">Docs</a>
            <a class="page-link" href="https://github.com/metadot/daskeyboard.github.io">GitHub</a>
            <a class="page-link" href="https://daskeyboard.mojohelpdesk.com/">Support</a>
            <a class="page-link" id="login-link" href="https://q.daskeyboard.com/signin">Login</a>
          </div>
        </nav>
      </div>
    </div> <!-- /.row -->
  </div> <!-- /.container -->
</header>

    <!-- Page Content -->
    <div class="container-fluid contents">
      <!-- Content Row -->
      <div class="row">

        <!-- Sidebar Column -->
        <div id="side-nav-container" class="col-sm-3">
          <ul id="mysidebar" class="nav">

  <li class="sidebar-title">Get started</li>
  <ul class="sidebar-items">
    <li><a href="/daskeyboard.github.io/get-started/download/">1: Download</a></li>
    <li><a href="/daskeyboard.github.io/get-started/welcome-video/">2: Watch the Welcome video</a></li>
    <li><a href="/daskeyboard.github.io/get-started/ifttt-tutorial/">3: Watch the IFTTT tutorial</a></li>
    <li><a href="/daskeyboard.github.io/get-started/zapier-tutorial/">4: Watch the Zapier tutorial</a></li>
  </ul>

  <li class="sidebar-title">Q Developer API</li>
  <ul class="sidebar-items">
    <li><a href="/daskeyboard.github.io/q-api-quick-start/">Quick start</a></li>
    <li><a href="/daskeyboard.github.io/q-api-doc/">Full documentation</a></li>
    <li><a href="/daskeyboard.github.io/contributed-links/">Community contributions</a></li>
    <li><a href="/daskeyboard.github.io/script-examples/">API examples</a></li>
    <li><a href="https://qforum.daskeyboard.com">Developer forum</a></li>
  </ul>

  <li class="sidebar-title">Q software updates</li>
  <ul class="sidebar-items">
    <li><a href="/daskeyboard.github.io/updates/1.0.0-beta.43/">1.0.0 Beta.43</a></li>
    <li><a href="/daskeyboard.github.io/updates/1.0.0-beta.37/">1.0.0 Beta.37</a></li>
    <li><a href="/daskeyboard.github.io/updates/1.0.0-beta.35/">1.0.0 Beta.35</a></li>
    <li><a href="/daskeyboard.github.io/updates/1.0.0-beta.31/">1.0.0 Beta.31</a></li>
    <li><a href="/daskeyboard.github.io/updates/1.0.0-beta.30/">1.0.0 Beta.30</a></li>
    <li><a href="/daskeyboard.github.io/updates/1.0.0-beta.29/">1.0.0 Beta.29</a></li>
    <li><a href="/daskeyboard.github.io/updates/1.0.0-beta.28/">1.0.0 Beta.28</a></li>
  </ul>
</ul>

        </div>

        
        

        <!-- Content Column -->
        <div class="col-sm-9 main-contents">
          <div class="main-contents-body">
            <article class="post-content">
  
  
  <header class="post-header">
      <div class="btn-group contribute" role="group">
         <a href="https://github.com/metadot/daskeyboard.github.io/blob/master/script-examples/cpu-percentage.md" class="btn btn-sm">
            <i class="fa fa-pencil"></i> Edit Source
         </a>
         <a href="https://github.com/DasKeyboard/q/issues/new?title=Issue from website page Display the CPU percentage&body=From URL: https://daskeyboard.github.io/script-examples/cpu-percentage.md&labels=dev: docs - website" class="btn btn-sm">
            <i class="fa fa-github"></i> File Issue
        </a>
     </div>
   <div>
    <h1 class="post-title">Display the CPU percentage </h1>
   </div>

  </header>
  

  <ul class="tabs__top-bar">
  <!-- <li class="tab-link current" data-tab="tab-install-go">Go</li>
  <li class="tab-link" data-tab="tab-install-go-optimized">Go - script optimized</li>
  <li class="tab-link" data-tab="tab-install-go-windows">Go - script for Windows</li> -->
  <li class="tab-link current" data-tab="tab-install-node">Node</li>
  <li class="tab-link" data-tab="tab-install-shell">Shell</li>
</ul>

<!-- <div id="tab-install-go" class="tabs__content current" markdown="1">
```go
package main

import (
  "bufio"
  "bytes"
  "encoding/json"
  "fmt"
  "log"
  "net/http"
  "os"
  "os/signal"
  "runtime"
  "strconv"
  "strings"
  "time"
)

type mySignal struct {
  ID           int64  `json:"id"`           // Not used when creating a signal
  Pid          string `json:"pid"`          // DK5QPID
  ZoneID       string `json:"zoneId"`       // KEY_A, KEY_B, etc...
  Name         string `json:"name"`         // message title
  Message      string `json:"message"`      // message body
  Effect       string `json:"effect"`       // e.g. SET_COLOR, BLINK, etc...
  Color        string `json:"color"`        // color in hex format. E.g.: "#FF0044"
  ShouldNotify bool   `json:"shouldNotify"` // whether to show a OS notification
}

// check checks for error and log out if there is one
func check(err error) {
  if err != nil {
    log.Fatal(err)
  }
}

// checkForInterruption creates a concurrent function that launch a funtion when the program is interrupted by the user
func checkForInterruption(ospid int, nameOfProgram string, pid string, url string) {
  // this is to get the stop of the program and display a message when the user stops the program
  c := make(chan os.Signal, 1)
  signal.Notify(c, os.Interrupt)
  go func() {
    <-c
    for i := 0; i <= 9; i++ {
      switchOffKey(i, pid, url)
    }
    fmt.Printf("\nStopping process %d: %s\n", ospid, nameOfProgram)
    os.Exit(0)
  }()
}

// getAllCpusValues returns the infos on the cpu used by the user
func getAllCpusValues(numberOfCPU int) []string {
  // we look into hte file /proc/stat for the values of the cpus
  f, err := os.Open("/proc/stat")
  check(err)

  bf := bufio.NewReader(f)
  cpus := make([]string, numberOfCPU+1)
  // we read only the first lines to get only the cpus
  for lnum := 0; lnum < numberOfCPU+1; lnum++ {
    line, err := bf.ReadString('\n')
    cpus[lnum] = line
    check(err)
  }

  f.Close()
  // in this array there is the names and the values necessary to compute the max cpu percentage
  return cpus
}

// getValuesForSpecificCPU returns the values of a specific cpu to calculate its percentage
func getValuesForSpecificCPU(cpu int, cpus []string) []string {
  // since the first value of the array is the avg cpu
  valuesCPU := strings.Split(cpus[cpu+1], " ")

  return valuesCPU
}

// calculateMaxCPUPercentage calculates the percentages of all the cpus and put the values in an array
func calculateMaxCPUPercentage(indexCPU int, cpu []string, prevIdles []int, prevTotals []int) (int, int, int) {
  total := 0
  idle, err := strconv.Atoi(cpu[4])

  check(err)
  // here we get the total
  for j := 1; j <= 5; j++ {
    valueInt, err := strconv.Atoi(cpu[j])
    check(err)
    total += valueInt
  }
  // here we get the percentage using the total and the idle
  diffIdle := idle - prevIdles[indexCPU]
  diffTotal := total - prevTotals[indexCPU]
  percentage := (1000*(diffTotal-diffIdle)/diffTotal + 5) / 10
  // we then return the percentage to put it in an array
  return percentage, idle, total
}

// calculateAvgCPUPercentage calculates the percentage of the avg cpu, the algorithm is quite the same as the one used to calculate the max.
// But since we don't use the same the same types in the parameters, I decided to use another function
func calculateAvgCPUPercentage(cpu []string, prevIdle int, prevTotal int) (int, int, int) {
  total := 0
  idle, err := strconv.Atoi(cpu[5])

  check(err)
  // here we get the total
  for j := 2; j <= 6; j++ {
    valueInt, err := strconv.Atoi(cpu[j])
    check(err)
    total += valueInt
  }
  // here we get the percentage using the total and the idle
  diffIdle := idle - prevIdle
  diffTotal := total - prevTotal
  percentage := (1000*(diffTotal-diffIdle)/diffTotal + 5) / 10

  return percentage, idle, total
}

// getMaxFromArray returns the max value in an in array
func getMaxFromArray(array []int) int {
  max := array[0]
  for i := 0; i < len(array); i++ {
    if array[i] > max {
      max = array[i]
    }
  }

  return max
}

// getMaxPercentage returns the percentage of the max cpu
func getMaxPercentage(cpus []string, numberOfCPU int, percentages []int, prevIdles []int, prevTotals []int) (int, []int, []int, []int) {
  // we get the percentage of usage for each cpu
  for i := 0; i < numberOfCPU; i++ {
    values := getValuesForSpecificCPU(i, cpus)

    percentages[i], prevIdles[i], prevTotals[i] = calculateMaxCPUPercentage(i, values, prevIdles, prevTotals)

  }
  // we get the max of the array "percentages"
  maxPercentage := getMaxFromArray(percentages)

  return maxPercentage, percentages, prevIdles, prevTotals
}

// getRangeOfKey returns the range of the keys to colorize according to the percentage
func getRangeOfKey(percentage int) int {
  // this is to make sure that if the percentage is for example 56%, we limitKey is 6 and not 5
  if percentage%10 >= 5 && percentage <= 95 {
    percentage += 5
  }
  limitKey := percentage * 10 / 100
  if limitKey == 0 {
    limitKey = 1
  }
  return limitKey
}

// sendSignal sends a signal to the public api
func sendSignal(color string, key string, pid string, url string, effect string, name string, message string) error {
  oneSignal := mySignal{0,
    pid,
    key,
    name,
    message,
    effect,
    color,
    false}
  signalJSON := new(bytes.Buffer)
  json.NewEncoder(signalJSON).Encode(&oneSignal)
  _, err := http.Post(url, "application/json; charset=utf-8", signalJSON)
  fmt.Println("ok")
  return err
}

// switchOffKey switches off keys on the keyboard
func switchOffKey(key int, pid string, url string) {
  keyString := "KEY_" + strconv.Itoa(key)
  err := sendSignal("#000", keyString, pid, url, "NONE", "", "")
  check(err)

}

// sendSignalToInBetweenKey switches on the keys between the key "1" and the "limitKey"
// since only the max cpu is represented by switching on all the keys until the limitKey,'
// we only need to send signal with the green color (the one used for the max cpu)
func sendSignalToInBetweenKey(key int, pid string, url string) {
  keyString := "KEY_" + strconv.Itoa(key)
  err := sendSignal("#0fff77", keyString, pid, url, "SET_COLOR", "", "")
  check(err)

}

// sendSignalToEndKey sends a signal to the end key
// one of the parameter is called "isSwitchingOnAvgCPU", this parameter is used to know if the function is called to switch on
// the end key for the avg cpu or the max cpu, if isSwitchingOnAvgCPU is true, then we are switching on the end key of the avg cpu,
// if it is false, we are switching on the end key of the max cpu
func sendSignalToEndKey(key int, isSwitchingOnAvgCPU bool, pid string, url string) {
  keyString := "KEY_" + strconv.Itoa(key)
  // if we are switching on the end key for the avg cpu, we send a blue color
  if isSwitchingOnAvgCPU {
    err := sendSignal("#0fa7ff", keyString, pid, url, "SET_COLOR", "", "")
    check(err)

  } else {
    // if we are switching on the end key for the max cpu, we send a green color
    err := sendSignal("#0fff77", keyString, pid, url, "SET_COLOR", "", "")
    check(err)
  }

}

// colorizeKeys colorizes the keys according to the limitKey given in parameter
func colorizeKeys(limitKey int, isSwitchingOnAvgCPU bool, pid string, url string, limitKeyAvg int) {
  // this is to make sure that the first key will be switched on even if the percentage is very low
  if limitKey == 0 {
    limitKey = 1
  }
  // first we switch on the keys used to represent the max cpu
  if !isSwitchingOnAvgCPU {
    for i := 1; i < limitKey; i++ {
      // this is to make sure that we don't replace the color of the avg cpu, the max cpu can't send a signal to replace the avg cpu
      if i != limitKeyAvg {
        sendSignalToInBetweenKey(i, pid, url)
      }
    }
  }
  // if the max key is 10, this means that the end key is 0 (since it is the key after the key "9")
  if limitKey == 10 {
    limitKey = 0
  }

  // we chech if we are switching on the avg cpu,
  if isSwitchingOnAvgCPU {
    // we make sure that the avg cpu representing the cpu only send signal to switched off keys or key switched on to represent the max cpu
    sendSignalToEndKey(limitKey, isSwitchingOnAvgCPU, pid, url)
  } else {
    // here we send a signal to the end key to represent the max cpu only if it doesn't overwrite the avg cpu key
    // and only if the key is switched off or switched on by the avg cpu (the previous key representing the avg cpu, since we can't
    // overwrite the current one)
    if limitKey != limitKeyAvg {
      sendSignalToEndKey(limitKey, isSwitchingOnAvgCPU, pid, url)
    }
  }
}

// switchOffUnnecessaryKeys switches off the keys that don't need to be switched on
func switchOffUnnecessaryKeys(limitKey int, pid string, url string) {
  limitKey++
  // we loop through the keys from the limit of the max cpu to the "0" key
  // we use the limit of the max cpu because the avg cpu can't go beyond the max cpu, it can only equal it
  for i := limitKey; i <= 9; i++ {
    switchOffKey(i, pid, url)
  }
  // here we check if the max key is 0 or not, if it isn't, then we switch off the "0" key
  // because we don't want to switch off a key that doesn't need to be switched on
  switchOffKey(0, pid, url)
}

// colorizeKeyboard colorizes the keyboard number row with the max cpu percentage and the avg cpu percentage
func colorizeKeyboard(maxPercentage int, avgPercentage int, pid string, url string) {
  // first we get the range of key for the avg cpu
  limitKeyAvg := getRangeOfKey(avgPercentage)
  // then we get the range of key for the max cpu
  maxKeyMax := getRangeOfKey(maxPercentage)
  // we start by colorizing the keys for the max cpu
  colorizeKeys(maxKeyMax, false, pid, url, limitKeyAvg)
  // the we colorize the key for the avg cpu, since the avg cpu can't go beyond the max cpu
  colorizeKeys(limitKeyAvg, true, pid, url, limitKeyAvg)

  switchOffUnnecessaryKeys(maxKeyMax, pid, url)
}

// sendSignalForAnimation switches on a key for the animation
func sendSignalForAnimation(pid string, url string, key string) {
  sendSignal("#fff", key, pid, url, "COLOR_CYCLE", "cpu-meter", "Starting the program")
}

// switchOffKeyForAnimation switches off a key for the animation
func switchOffKeyForAnimation(pid string, url string, key string) {
  sendSignal("#000", key, pid, url, "NONE", "", "")
}

// displayAnimation writes "CPU" on the keyboard
func displayAnimation(pid string, url string) {
  // writing the C
  sendSignalForAnimation(pid, url, "72")
  sendSignalForAnimation(pid, url, "76")
  sendSignalForAnimation(pid, url, "75")
  sendSignalForAnimation(pid, url, "99")
  sendSignalForAnimation(pid, url, "123")
  sendSignalForAnimation(pid, url, "124")
  // writing the P
  sendSignalForAnimation(pid, url, "78")
  sendSignalForAnimation(pid, url, "79")
  sendSignalForAnimation(pid, url, "80")
  sendSignalForAnimation(pid, url, "103")
  sendSignalForAnimation(pid, url, "104")
  sendSignalForAnimation(pid, url, "105")
  sendSignalForAnimation(pid, url, "127")
  // writing the U
  sendSignalForAnimation(pid, url, "82")
  sendSignalForAnimation(pid, url, "85")
  sendSignalForAnimation(pid, url, "107")
  sendSignalForAnimation(pid, url, "109")
  sendSignalForAnimation(pid, url, "131")
  sendSignalForAnimation(pid, url, "132")
  sendSignalForAnimation(pid, url, "71")

  time.Sleep(3 * time.Second)

  switchOffKeyForAnimation(pid, url, "72")
  switchOffKeyForAnimation(pid, url, "76")
  switchOffKeyForAnimation(pid, url, "75")
  switchOffKeyForAnimation(pid, url, "99")
  switchOffKeyForAnimation(pid, url, "123")
  switchOffKeyForAnimation(pid, url, "124")
  switchOffKeyForAnimation(pid, url, "78")
  switchOffKeyForAnimation(pid, url, "79")
  switchOffKeyForAnimation(pid, url, "80")
  switchOffKeyForAnimation(pid, url, "103")
  switchOffKeyForAnimation(pid, url, "104")
  switchOffKeyForAnimation(pid, url, "105")
  switchOffKeyForAnimation(pid, url, "127")
  switchOffKeyForAnimation(pid, url, "82")
  switchOffKeyForAnimation(pid, url, "85")
  switchOffKeyForAnimation(pid, url, "107")
  switchOffKeyForAnimation(pid, url, "109")
  switchOffKeyForAnimation(pid, url, "131")
  switchOffKeyForAnimation(pid, url, "132")
  switchOffKeyForAnimation(pid, url, "71")
}

func main() {
  // first we initialize the variables and constants for
  nameOfProgram := "cpu-meter"
  numberOfCPU := runtime.NumCPU()
  const numberOfKey int = 10

  ospid := os.Getpid()

  port := "27301"
  url := "http://localhost:" + port + "/api/1.0/signals"
  pid := "DK5QPID"

  prevTotals := make([]int, numberOfCPU)
  percentages := make([]int, numberOfCPU)
  prevIdles := make([]int, numberOfCPU)
  prevIdle := 0
  prevTotal := 0
  avgPercentage := 0
  maxPercentage := 0

  fmt.Printf("Starting process %d: %s\n", ospid, nameOfProgram)

  // first we switch off all the keys of the row to make sure that no "noise" color are displayed
  // when launching the script
  for i := 0; i <= 9; i++ {
    switchOffKey(i, pid, url)
  }

  displayAnimation(pid, url)

  checkForInterruption(ospid, nameOfProgram, pid, url)

  for true {

    cpus := getAllCpusValues(numberOfCPU)
    // here we get the values used for the avg cpus (it is at the index 0)
    values := getValuesForSpecificCPU(-1, cpus)
    // we compute the avg cpu percentage
    avgPercentage, prevIdle, prevTotal = calculateAvgCPUPercentage(values, prevIdle, prevTotal)
    // we get the max cpu percentage
    maxPercentage, percentages, prevIdles, prevTotals = getMaxPercentage(cpus, numberOfCPU, percentages, prevIdles, prevTotals)
    // we colorize the keyboard with the values of the percentages
    colorizeKeyboard(maxPercentage, avgPercentage, pid, url)

    fmt.Printf("\r (blue) avg cpu: %3d%%    (green) max cpu: %3d%%", avgPercentage, maxPercentage)
    time.Sleep(1 * time.Second)
  }

}
```
</div>

<div id="tab-install-go-optimized" class="tabs__content" markdown="1">
```go
package main

import (
  "bufio"
  "bytes"
  "encoding/json"
  "fmt"
  "log"
  "net/http"
  "os"
  "os/signal"
  "runtime"
  "strconv"
  "strings"
  "time"
)

type mySignal struct {
  ID           int64  `json:"id"`           // Not used when creating a signal
  Pid          string `json:"pid"`          // DK5QPID
  ZoneID       string `json:"zoneId"`       // KEY_A, KEY_B, etc...
  Name         string `json:"name"`         // message title
  Message      string `json:"message"`      // message body
  Effect       string `json:"effect"`       // e.g. SET_COLOR, BLINK, etc...
  Color        string `json:"color"`        // color in hex format. E.g.: "#FF0044"
  ShouldNotify bool   `json:"shouldNotify"` // whether to show a OS notification
}

// check checks for error and log out if there is one
func check(err error) {
  if err != nil {
    log.Fatal(err)
  }
}

// checkForInterruption creates a concurrent function that launch a funtion when the program is interrupted by the user
func startLookingForInterruption(ospid int, nameOfProgram string, pid string, url string, alreadyLit []int) {
  // this is to get the stop of the program and display a message when the user stops the program
  c := make(chan os.Signal, 1)
  signal.Notify(c, os.Interrupt)
  go func() {
    <-c
    for i := 0; i <= 9; i++ {
      switchOffKey(i, pid, url, alreadyLit)
    }
    fmt.Printf("\nStopping process %d: %s\n", ospid, nameOfProgram)
    os.Exit(0)
  }()
}

// getAllCpusValues returns the infos on the cpu used by the user
func getAllCpusValues(numberOfCPU int) []string {
  // we look into hte file /proc/stat for the values of the cpus
  f, err := os.Open("/proc/stat")
  check(err)

  bf := bufio.NewReader(f)
  cpus := make([]string, numberOfCPU+1)
  // we read only the first lines to get only the cpus
  for lnum := 0; lnum < numberOfCPU+1; lnum++ {
    line, err := bf.ReadString('\n')
    cpus[lnum] = line
    check(err)
  }

  f.Close()
  // in this array there is the names and the values necessary to compute the max cpu percentage
  return cpus
}

// getValuesForSpecificCPU returns the values of a specific cpu to calculate its percentage
func getValuesForSpecificCPU(cpu int, cpus []string) []string {
  // since the first value of the array is the avg cpu
  valuesCPU := strings.Split(cpus[cpu+1], " ")

  return valuesCPU
}

// calculateMaxCPUPercentage calculates the percentages of all the cpus and put the values in an array
func calculateMaxCPUPercentage(indexCPU int, cpu []string, prevIdles []int, prevTotals []int) (int, int, int) {
  total := 0
  idle, err := strconv.Atoi(cpu[4])

  check(err)
  // here we get the total
  for j := 1; j <= 5; j++ {
    valueInt, err := strconv.Atoi(cpu[j])
    check(err)
    total += valueInt
  }
  // here we get the percentage using the total and the idle
  diffIdle := idle - prevIdles[indexCPU]
  diffTotal := total - prevTotals[indexCPU]
  percentage := (1000*(diffTotal-diffIdle)/diffTotal + 5) / 10
  // we then return the percentage to put it in an array
  return percentage, idle, total
}

// calculateAvgCPUPercentage calculates the percentage of the avg cpu, the algorithm is quite the same as the one used to calculate the max.
// But since we don't use the same the same types in the parameters, I decided to use another function
func calculateAvgCPUPercentage(cpu []string, prevIdle int, prevTotal int) (int, int, int) {
  total := 0
  idle, err := strconv.Atoi(cpu[5])

  check(err)
  // here we get the total
  for j := 2; j <= 6; j++ {
    valueInt, err := strconv.Atoi(cpu[j])
    check(err)
    total += valueInt
  }
  // here we get the percentage using the total and the idle
  diffIdle := idle - prevIdle
  diffTotal := total - prevTotal
  percentage := (1000*(diffTotal-diffIdle)/diffTotal + 5) / 10

  return percentage, idle, total
}

// getMaxFromArray returns the max value in an in array
func getMaxFromArray(array []int) int {
  max := array[0]
  for i := 0; i < len(array); i++ {
    if array[i] > max {
      max = array[i]
    }
  }

  return max
}

// getMaxPercentage returns the percentage of the max cpu
func getMaxPercentage(cpus []string, numberOfCPU int, percentages []int, prevIdles []int, prevTotals []int) (int, []int, []int, []int) {
  // we get the percentage of usage for each cpu
  for i := 0; i < numberOfCPU; i++ {
    values := getValuesForSpecificCPU(i, cpus)

    percentages[i], prevIdles[i], prevTotals[i] = calculateMaxCPUPercentage(i, values, prevIdles, prevTotals)

  }
  // we get the max of the array "percentages"
  maxPercentage := getMaxFromArray(percentages)

  return maxPercentage, percentages, prevIdles, prevTotals
}

// getRangeOfKey returns the range of the keys to colorize according to the percentage
func getRangeOfKey(percentage int) int {
  // this is to make sure that if the percentage is for example 56%, we maxKey is 6 and not 5
  if percentage%10 >= 5 && percentage <= 95 {
    percentage += 5
  }
  maxKey := percentage * 10 / 100
  if maxKey == 0 {
    maxKey = 1
  }
  return maxKey
}

// getSwitchedState returns the state of a key (0 : it is switched off, 1 : it is switched on for the max cpu, 2 : it is switched on for the avg cpu)
func getSwitchedState(key int, alreadyLit []int) int {
  if alreadyLit[key] == 1 {
    return 1
  } else if alreadyLit[key] == 0 {
    return 0
  }
  return 2
}

// sendSignal sends a signal to the public api
func sendSignal(color string, key string, pid string, url string, effect string, name string, message string) error {
  oneSignal := mySignal{0,
    pid,
    key,
    name,
    message,
    effect,
    color,
    false}
  signalJSON := new(bytes.Buffer)
  json.NewEncoder(signalJSON).Encode(&oneSignal)
  _, err := http.Post(url, "application/json; charset=utf-8", signalJSON)
  return err
}

// switchOffKey switches off keys on the keyboard
func switchOffKey(key int, pid string, url string, alreadyLit []int) []int {
  keyString := "KEY_" + strconv.Itoa(key)
  err := sendSignal("#000", keyString, pid, url, "NONE", "", "")
  check(err)

  alreadyLit[key] = 0

  return alreadyLit
}

// sendSignalToInBetweenKey switches on the keys between the key "1" and the "maxkey"
// since only the max cpu is represented by switching on all the keys until the maxkey,'
// we only need to send signal with the green color (the one used for the max cpu)
func sendSignalToInBetweenKey(key int, pid string, url string, alreadyLit []int) []int {
  keyString := "KEY_" + strconv.Itoa(key)
  err := sendSignal("#0fff77", keyString, pid, url, "SET_COLOR", "", "")
  check(err)
  alreadyLit[key] = 1

  return alreadyLit
}

// sendSignalToEndKey sends a signal to the end key
// one of the parameter is called "isSwitchingOnAvgCPU", this parameter is used to know if the function is called to switch on
// the end key for the avg cpu or the max cpu, if isSwitchingOnAvgCPU is true, then we are switching on the end key of the avg cpu,
// if it is false, we are switching on the end key of the max cpu
func sendSignalToEndKey(key int, isSwitchingOnAvgCPU bool, pid string, url string, alreadyLit []int) []int {
  keyString := "KEY_" + strconv.Itoa(key)
  // if we are switching on the end key for the avg cpu, we send a blue color
  if isSwitchingOnAvgCPU {
    err := sendSignal("#0fa7ff", keyString, pid, url, "SET_COLOR", "", "")
    check(err)
    // we put the fact that we switched on the end key to represent the avg cpu
    alreadyLit[key] = 2
  } else {
    // if we are switching on the end key for the max cpu, we send a green color
    err := sendSignal("#0fff77", keyString, pid, url, "SET_COLOR", "", "")
    check(err)
    // we put the fact that we switched on the end key to represenet the max cpu
    alreadyLit[key] = 1
  }

  return alreadyLit
}

// colorizeKeys colorizes the keys according to the maxKey given in parameter
func colorizeKeys(maxKey int, isSwitchingOnAvgCPU bool, pid string, url string, maxKeyAvg int, alreadyLit []int) []int {
  // this is to make sure that the first key will be switched on even if the percentage is very low
  if maxKey == 0 {
    maxKey = 1
  }
  // first we switch on the keys used to represent the max cpu
  if !isSwitchingOnAvgCPU {
    for i := 1; i < maxKey; i++ {
      // this is to make sure that we don't replace the color of the avg cpu, the max cpu can't send a signal to replace the avg cpu
      if i != maxKeyAvg {
        state := getSwitchedState(i, alreadyLit)
        // only if the key is switched off or was switched on by the avg, we switch on the key
        if state == 0 || state == 2 {
          alreadyLit = sendSignalToInBetweenKey(i, pid, url, alreadyLit)
        }
      }
    }
  }
  // if the max key is 10, this means that the end key is 0 (since it is the key after the key "9")
  if maxKey == 10 {
    maxKey = 0
  }

  // we chech if we are switching on the avg cpu,
  if isSwitchingOnAvgCPU {
    // we make sure that the avg cpu representing the cpu only send signal to switched off keys or key switched on to represent the max cpu
    // we don't send a signal if the key that represents the avg cpu hasn't changed
    if state := getSwitchedState(maxKey, alreadyLit); state != 2 {
      alreadyLit = sendSignalToEndKey(maxKey, isSwitchingOnAvgCPU, pid, url, alreadyLit)
    }
  } else {
    // here we send a signal to the end key to represent the max cpu only if it doesn't overwrite the avg cpu key
    // and only if the key is switched off or switched on by the avg cpu (the previous key representing the avg cpu, since we can't
    // overwrite the current one)
    if maxKey != maxKeyAvg {
      state := getSwitchedState(maxKey, alreadyLit)
      if state != 1 {
        alreadyLit = sendSignalToEndKey(maxKey, isSwitchingOnAvgCPU, pid, url, alreadyLit)
      }
    }
  }

  return alreadyLit
}

// switchOffUnnecessaryKeys switches off the keys that don't need to be switched on
func switchOffUnnecessaryKeys(maxKey int, pid string, url string, alreadyLit []int) []int {
  maxKey++
  // we loop through the keys from the maxKey of the max cpu to the "0" key
  // we use the maxKey of the max cpu because the avg cpu can't go beyond the max cpu, it can only equal it
  for i := maxKey; i <= 9; i++ {
    state := getSwitchedState(i, alreadyLit)
    // if the key is not switched off, we switch it off
    if state != 0 {
      alreadyLit = switchOffKey(i, pid, url, alreadyLit)
    }
  }
  // here we check if the max key is 0 or not, if it isn't, then we switch off the "0" key
  // because we don't want to switch off a key that doesn't need to be switched on
  if state := getSwitchedState(0, alreadyLit); maxKey != 11 && state != 0 {
    alreadyLit = switchOffKey(0, pid, url, alreadyLit)
  }

  return alreadyLit
}

// colorizeKeyboard colorizes the keyboard number row with the max cpu percentage and the avg cpu percentage
func colorizeKeyboard(maxPercentage int, avgPercentage int, alreadyLit []int, pid string, url string) []int {
  // first we get the range of key for the avg cpu
  maxKeyAvg := getRangeOfKey(avgPercentage)
  // then we get the range of key for the max cpu
  maxKeyMax := getRangeOfKey(maxPercentage)
  // we start by colorizing the keys for the max cpu
  alreadyLit = colorizeKeys(maxKeyMax, false, pid, url, maxKeyAvg, alreadyLit)
  // the we colorize the key for the avg cpu, since the avg cpu can't go beyond the max cpu
  alreadyLit = colorizeKeys(maxKeyAvg, true, pid, url, maxKeyAvg, alreadyLit)

  alreadyLit = switchOffUnnecessaryKeys(maxKeyMax, pid, url, alreadyLit)

  return alreadyLit
}

// sendSignalForAnimation switches on a key for the animation
func sendSignalForAnimation(pid string, url string, key string) {
  sendSignal("#fff", key, pid, url, "COLOR_CYCLE", "cpu-meter", "Starting the program")
}

// switchOffKeyForAnimation switches off a key for the animation
func switchOffKeyForAnimation(pid string, url string, key string) {
  sendSignal("#000", key, pid, url, "NONE", "", "")
}

// displayAnimation writes "CPU" on the keyboard
func displayAnimation(pid string, url string) {
  // writing the C
  sendSignalForAnimation(pid, url, "72")
  sendSignalForAnimation(pid, url, "76")
  sendSignalForAnimation(pid, url, "75")
  sendSignalForAnimation(pid, url, "99")
  sendSignalForAnimation(pid, url, "123")
  sendSignalForAnimation(pid, url, "124")
  // writing the P
  sendSignalForAnimation(pid, url, "78")
  sendSignalForAnimation(pid, url, "79")
  sendSignalForAnimation(pid, url, "80")
  sendSignalForAnimation(pid, url, "103")
  sendSignalForAnimation(pid, url, "104")
  sendSignalForAnimation(pid, url, "105")
  sendSignalForAnimation(pid, url, "127")
  // writing the U
  sendSignalForAnimation(pid, url, "82")
  sendSignalForAnimation(pid, url, "85")
  sendSignalForAnimation(pid, url, "107")
  sendSignalForAnimation(pid, url, "109")
  sendSignalForAnimation(pid, url, "131")
  sendSignalForAnimation(pid, url, "132")
  sendSignalForAnimation(pid, url, "71")

  time.Sleep(3 * time.Second)

  switchOffKeyForAnimation(pid, url, "72")
  switchOffKeyForAnimation(pid, url, "76")
  switchOffKeyForAnimation(pid, url, "75")
  switchOffKeyForAnimation(pid, url, "99")
  switchOffKeyForAnimation(pid, url, "123")
  switchOffKeyForAnimation(pid, url, "124")
  switchOffKeyForAnimation(pid, url, "78")
  switchOffKeyForAnimation(pid, url, "79")
  switchOffKeyForAnimation(pid, url, "80")
  switchOffKeyForAnimation(pid, url, "103")
  switchOffKeyForAnimation(pid, url, "104")
  switchOffKeyForAnimation(pid, url, "105")
  switchOffKeyForAnimation(pid, url, "127")
  switchOffKeyForAnimation(pid, url, "82")
  switchOffKeyForAnimation(pid, url, "85")
  switchOffKeyForAnimation(pid, url, "107")
  switchOffKeyForAnimation(pid, url, "109")
  switchOffKeyForAnimation(pid, url, "131")
  switchOffKeyForAnimation(pid, url, "132")
  switchOffKeyForAnimation(pid, url, "71")

}

func main() {
  // first we initialize the variables and constants for
  nameOfProgram := "cpu-meter"
  numberOfCPU := runtime.NumCPU()
  const numberOfKey int = 10

  ospid := os.Getpid()

  port := "27301"
  url := "http://localhost:" + port + "/api/1.0/signals"
  pid := "DK5QPID"

  prevTotals := make([]int, numberOfCPU)
  percentages := make([]int, numberOfCPU)
  prevIdles := make([]int, numberOfCPU)
  alreadyLit := make([]int, numberOfKey)
  prevIdle := 0
  prevTotal := 0
  avgPercentage := 0
  maxPercentage := 0

  fmt.Printf("Starting process %d: %s\n", ospid, nameOfProgram)

  // first we switch off all the keys of the row to make sure that no "noise" color are displayed
  // when launching the script
  for i := 0; i <= 9; i++ {
    switchOffKey(i, pid, url, alreadyLit)
  }

  displayAnimation(pid, url)

  startLookingForInterruption(ospid, nameOfProgram, pid, url, alreadyLit)

  for true {

    cpus := getAllCpusValues(numberOfCPU)
    // here we get the values used for the avg cpus (it is at the index 0)
    values := getValuesForSpecificCPU(-1, cpus)
    // we compute the avg cpu percentage
    avgPercentage, prevIdle, prevTotal = calculateAvgCPUPercentage(values, prevIdle, prevTotal)
    // we get the max cpu percentage
    maxPercentage, percentages, prevIdles, prevTotals = getMaxPercentage(cpus, numberOfCPU, percentages, prevIdles, prevTotals)
    // we colorize the keyboard with the values of the percentages
    alreadyLit = colorizeKeyboard(maxPercentage, avgPercentage, alreadyLit, pid, url)

    fmt.Printf("\r (blue) avg cpu: %3d%%    (green) max cpu: %3d%%", avgPercentage, maxPercentage)
    time.Sleep(1 * time.Second)
  }

}
```
</div>

<div id="tab-install-go-windows" class="tabs__content" markdown="1">
```go
package main

import (
  "bytes"
  "encoding/json"
  "fmt"
  "log"
  "net/http"
  "os"
  "os/signal"
  "runtime"
  "strconv"
  "strings"
  "time"

  ps "github.com/gorillalabs/go-powershell"
  "github.com/gorillalabs/go-powershell/backend"
  "github.com/shirou/gopsutil/cpu"
)

type mySignal struct {
  ID           int64  `json:"id"`           // Not used when creating a signal
  Pid          string `json:"pid"`          // DK5QPID
  ZoneID       string `json:"zoneId"`       // KEY_A, KEY_B, etc...
  Name         string `json:"name"`         // message title
  Message      string `json:"message"`      // message body
  Effect       string `json:"effect"`       // e.g. SET_COLOR, BLINK, etc...
  Color        string `json:"color"`        // color in hex format. E.g.: "#FF0044"
  ShouldNotify bool   `json:"shouldNotify"` // whether to show a OS notification
}

// this function checks for error
func check(err error) {
  if err != nil {
    log.Fatal(err)
  }
}

// checkForInterruption creates a concurrent function that launch a funtion when the program is interrupted by the user
func startLookingForInterruption(ospid int, nameOfProgram string, pid string, url string, alreadyLit []int) {
  // this is to get the stop of the program and display a message when the user stops the program
  c := make(chan os.Signal, 1)
  signal.Notify(c, os.Interrupt)
  go func() {
    <-c
    for i := 0; i <= 9; i++ {
      switchOffKey(i, pid, url, alreadyLit)
    }
    fmt.Printf("\nStopping process %d: %s\n", ospid, nameOfProgram)
    os.Exit(0)
  }()
}

  // this function gets the percentage of all the cpus and returns an array with the percentages in it
  func getCpusPercentage(numberOfCPU int, shell ps.Shell) []int {
  // first we get the cpus from a powershell command ans put them in a shell variable
  _, _, err := shell.Execute("$res = Get-WmiObject -Query \"select Name, PercentProcessorTime from Win32_PerfFormattedData_PerfOS_Processor\"")
  check(err)
  percentages := make([]int, numberOfCPU)
  // then for the all the cpus, we get the value, using a select-string command to find the value in the display of all the cpus
  for i := 0; i < numberOfCPU; i++ {
    result, _, err := shell.Execute("$(foreach($cpu in $res) {echo \"$($cpu.Name) : $($cpu.PercentProcessorTime)\"}) | Select-String -Pattern \"" + strconv.Itoa(i) + " :\"")
    check(err)
    if result != "" {
      // the string has not the same pattern whether it is the first result or the other results, that is why
      // there is a if
      // we trim the string that we receive, to make it usable
      if i == 0 {
        result = strings.TrimPrefix(result, "\r\n"+strconv.Itoa(i)+" : ")
      } else {
        result = strings.TrimPrefix(result, "\r\n\r\n\r\n"+strconv.Itoa(i)+" : ")
      }
      result = strings.TrimSuffix(result, "\r\n")
      // we convert the string to an int
      num, err := strconv.Atoi(result)
      check(err)
      // we put it in an array
      percentages[i] = num
    }
  }

  return percentages
  }

// this function returns the number of key that the cpu's percentage covers
func getRangeOfKey(percentage int) int {
  // this is to make sure that if the percentage is for example 56%, we maxKey is 6 and not 5
  if percentage%10 >= 5 && percentage <= 95 {
    percentage += 5
  }
  maxKey := percentage * 10 / 100
  if maxKey == 0 {
    maxKey = 1
  }
  return maxKey
}

// this function returns the max percentage in an array of percentages
func getMaxFromArray(array []int) int {
  max := array[0]
  for i := 0; i < len(array); i++ {
    if array[i] > max {
      max = array[i]
    }
  }

  return max
}

func getMaxPercentage(percentages []int, numberOfCPU int, shell ps.Shell, avgPercentage []float64) int {
  // then we get the max from this array
  maxPercentage := getMaxFromArray(percentages)
  // this is a little trick to make sure that the max percentage doesn't go below the avg cpu
  // since we don't get the max and the avg cpu at the same time, there might be some timing errors, causing
  // the avg cpu to sometimes (only sometimes) to be above the max cpu
  if maxPercentage < int(avgPercentage[0]) {
    maxPercentage = int(avgPercentage[0])
  }

  return maxPercentage
}

// this function is used to get the state of a key (0 : it is switched off, 1 : it is switched on for the max cpu, 2 : it is switched on for the avg cpu)
func getSwitchedState(key int, alreadyLit []int) int {
  if alreadyLit[key] == 1 {
    return 1
  } else if alreadyLit[key] == 0 {
    return 0
  }
  return 2
}

// this function sends a signal to the public api
func sendSignal(color string, key string, pid string, url string, effect string, name string, message string) error {
  oneSignal := mySignal{0,
    pid,
    key,
    name,
    message,
    effect,
    color,
    false}
  signalJSON := new(bytes.Buffer)
  json.NewEncoder(signalJSON).Encode(&oneSignal)
  _, err := http.Post(url, "application/json; charset=utf-8", signalJSON)
  return err
}

// this function sends a switch off signal to the public api
func switchOffKey(key int, pid string, url string, alreadyLit []int) []int {
  keyString := "KEY_" + strconv.Itoa(key)
  err := sendSignal("#000", keyString, pid, url, "NONE", "", "")
  check(err)

  alreadyLit[key] = 0

  return alreadyLit
}

// this function is used to switch on the keys between the key "1" and the "maxkey"
// since only the max cpu is represented by switching on all the keys until the maxkey,'
// we only need to send signal with the green color (the one used for the max cpu)
func sendSignalToInBetweenKey(key int, pid string, url string, alreadyLit []int) []int {
  keyString := "KEY_" + strconv.Itoa(key)
  err := sendSignal("#0fff77", keyString, pid, url, "SET_COLOR", "", "")
  check(err)
  alreadyLit[key] = 1

  return alreadyLit
}

// this function is used to send a signal to the end key
// one of the parameter is called "isSwitchingOnAvgCPU", this parameter is used to know if the function is called to switch on
// the end key for the avg cpu or the max cpu, if isSwitchingOnAvgCPU is true, then we are switching on the end key of the avg cpu,
// if it is false, we are switching on the end key of the max cpu
func sendSignalToEndKey(key int, isSwitchingOnAvgCPU bool, pid string, url string, alreadyLit []int) []int {
  keyString := "KEY_" + strconv.Itoa(key)
  // if we are switching on the end key for the avg cpu, we send a blue color
  if isSwitchingOnAvgCPU {
    err := sendSignal("#0fa7ff", keyString, pid, url, "SET_COLOR", "", "")
    check(err)
    // we put the fact that we switched on the end key to represent the avg cpu
    alreadyLit[key] = 2
  } else {
    // if we are switching on the end key for the max cpu, we send a green color
    err := sendSignal("#0fff77", keyString, pid, url, "SET_COLOR", "", "")
    check(err)
    // we put the fact that we switched on the end key to represenet the max cpu
    alreadyLit[key] = 1
  }

  return alreadyLit
}

// this function is used to colorize the keys according to the maxKey given in parameter
func colorizeKeys(maxKey int, isSwitchingOnAvgCPU bool, pid string, url string, maxKeyAvg int, alreadyLit []int) []int {
  // this is to make sure that the first key will be switched on even if the percentage is very low
  if maxKey == 0 {
    maxKey = 1
  }
  // first we switch on the keys used to represent the max cpu
  if !isSwitchingOnAvgCPU {
    for i := 1; i < maxKey; i++ {
      // this is to make sure that we don't replace the color of the avg cpu, the max cpu can't send a signal to replace the avg cpu
      if i != maxKeyAvg {
        state := getSwitchedState(i, alreadyLit)
        // only if the key is switched off or was switched on by the avg, we switch on the key
        if state == 0 || state == 2 {
          alreadyLit = sendSignalToInBetweenKey(i, pid, url, alreadyLit)
        }
      }
    }
  }
  // if the max key is 10, this means that the end key is 0 (since it is the key after the key "9")
  if maxKey == 10 {
    maxKey = 0
  }

	// we chech if we are switching on the avg cpu,
  if isSwitchingOnAvgCPU {
    // we make sure that the avg cpu representing the cpu only send signal to switched off keys or key switched on to represent the max cpu
    // we don't send a signal if the key that represents the avg cpu hasn't changed
    if state := getSwitchedState(maxKey, alreadyLit); state != 2 {
      alreadyLit = sendSignalToEndKey(maxKey, isSwitchingOnAvgCPU, pid, url, alreadyLit)
    }
  } else {
    // here we send a signal to the end key to represent the max cpu only if it doesn't overwrite the avg cpu key
    // and only if the key is switched off or switched on by the avg cpu (the previous key representing the avg cpu, since we can't
    // overwrite the current one)
    if maxKey != maxKeyAvg {
      state := getSwitchedState(maxKey, alreadyLit)
      if state != 1 {
        alreadyLit = sendSignalToEndKey(maxKey, isSwitchingOnAvgCPU, pid, url, alreadyLit)
      }
    }
  }

  return alreadyLit
}

// this function is used to switch off the keys that don't need to be switched on
func switchOffUnnecessaryKeys(maxKey int, pid string, url string, alreadyLit []int) []int {
  maxKey++
  // we loop through the keys from the maxKey of the max cpu to the "0" key
  // we use the maxKey of the max cpu because the avg cpu can't go beyond the max cpu, it can only equal it
  for i := maxKey; i <= 9; i++ {
    state := getSwitchedState(i, alreadyLit)
    // if the key is not switched off, we switch it off
    if state != 0 {
      alreadyLit = switchOffKey(i, pid, url, alreadyLit)
    }
  }
  // here we check if the max key is 0 or not, if it isn't, then we switch off the "0" key
  // because we don't want to switch off a key that doesn't need to be switched on
  if state := getSwitchedState(0, alreadyLit); maxKey != 11 && state != 0 {
    alreadyLit = switchOffKey(0, pid, url, alreadyLit)
  }

  return alreadyLit
}

// colorizeKeyboard colorizes the keyboard number row with the max cpu percentage and the avg cpu percentage
func colorizeKeyboard(maxPercentage int, avgPercentage int, alreadyLit []int, pid string, url string) []int {
  // first we get the range of key for the avg cpu
  maxKeyAvg := getRangeOfKey(avgPercentage)
  // then we get the range of key for the max cpu
  maxKeyMax := getRangeOfKey(maxPercentage)
  // we start by colorizing the keys for the max cpu
  alreadyLit = colorizeKeys(maxKeyMax, false, pid, url, maxKeyAvg, alreadyLit)
  // the we colorize the key for the avg cpu, since the avg cpu can't go beyond the max cpu
  alreadyLit = colorizeKeys(maxKeyAvg, true, pid, url, maxKeyAvg, alreadyLit)

  alreadyLit = switchOffUnnecessaryKeys(maxKeyMax, pid, url, alreadyLit)

  return alreadyLit
}

// this function is used to send a specific signal for the animation at the beginning
func sendSignalForAnimation(pid string, url string, key string) {
  sendSignal("#F00", key, pid, url, "COLOR_CYCLE", "cpu-meter", "Starting the program")
}

// this function is used to send a specific signal to switch off the keys at the end of the animation
func switchOffKeyForAnimation(pid string, url string, key string) {
  sendSignal("#000", key, pid, url, "NONE", "", "")
}

// this function is used to display a little animation at the launch of the program
// it writes "CPU" on the keyboard
func displayAnimation(pid string, url string) {
  // writing the C
  sendSignalForAnimation(pid, url, "72")
  sendSignalForAnimation(pid, url, "76")
  sendSignalForAnimation(pid, url, "75")
  sendSignalForAnimation(pid, url, "99")
  sendSignalForAnimation(pid, url, "123")
  sendSignalForAnimation(pid, url, "124")
  // writing the P
  sendSignalForAnimation(pid, url, "78")
  sendSignalForAnimation(pid, url, "79")
  sendSignalForAnimation(pid, url, "80")
  sendSignalForAnimation(pid, url, "103")
  sendSignalForAnimation(pid, url, "104")
  sendSignalForAnimation(pid, url, "105")
  sendSignalForAnimation(pid, url, "127")
  // writing the U
  sendSignalForAnimation(pid, url, "82")
  sendSignalForAnimation(pid, url, "85")
  sendSignalForAnimation(pid, url, "107")
  sendSignalForAnimation(pid, url, "109")
  sendSignalForAnimation(pid, url, "131")
  sendSignalForAnimation(pid, url, "132")
  sendSignalForAnimation(pid, url, "71")

  time.Sleep(3 * time.Second)

  switchOffKeyForAnimation(pid, url, "72")
  switchOffKeyForAnimation(pid, url, "76")
  switchOffKeyForAnimation(pid, url, "75")
  switchOffKeyForAnimation(pid, url, "99")
  switchOffKeyForAnimation(pid, url, "123")
  switchOffKeyForAnimation(pid, url, "124")
  switchOffKeyForAnimation(pid, url, "78")
  switchOffKeyForAnimation(pid, url, "79")
  switchOffKeyForAnimation(pid, url, "80")
  switchOffKeyForAnimation(pid, url, "103")
  switchOffKeyForAnimation(pid, url, "104")
  switchOffKeyForAnimation(pid, url, "105")
  switchOffKeyForAnimation(pid, url, "127")
  switchOffKeyForAnimation(pid, url, "82")
  switchOffKeyForAnimation(pid, url, "85")
  switchOffKeyForAnimation(pid, url, "107")
  switchOffKeyForAnimation(pid, url, "109")
  switchOffKeyForAnimation(pid, url, "131")
  switchOffKeyForAnimation(pid, url, "132")
  switchOffKeyForAnimation(pid, url, "71")

}

func main() {

  nameOfProgram := "cpu-meter"
  // first we initialize the variables and constants for
  const numberOfKey int = 10

  numberOfCPU := runtime.NumCPU()

  ospid := os.Getpid()

  port := "27301"
  url := "http://localhost:" + port + "/api/1.0/signals"
  pid := "DK5QPID"
  fmt.Printf("Starting process %d: %s\n", ospid, nameOfProgram)
  alreadyLit := make([]int, numberOfKey)

  back := &backend.Local{}

  shell, err := ps.New(back)
  check(err)

  defer shell.Exit()

  // first we switch off all the keys of the row to make sure that no "noise" color are displayed
  // when launching the script
  for i := 0; i <= 9; i++ {
    switchOffKey(i, pid, url, alreadyLit)
  }

  displayAnimation(pid, url)

  startLookingForInterruption(ospid, nameOfProgram, pid, url, alreadyLit)

  for true {
    // first we get the percentage of the avg cpu
    avgPercentage, err := cpu.Percent(time.Second, false)
    check(err)
    // then we get the array with the values of all the cpus usage
    percentages := getCpusPercentage(numberOfCPU, shell)

    maxPercentage := getMaxPercentage(percentages, numberOfCPU, shell, avgPercentage)

    alreadyLit = colorizeKeyboard(maxPercentage, int(avgPercentage[0]), alreadyLit, pid, url)

    fmt.Printf("\r (blue) avg cpu: %3d%%    (green) max cpu: %3d%%", int(avgPercentage[0]), int(maxPercentage))
    time.Sleep(1 * time.Second)
  }

}
```
</div> -->

<div id="tab-install-node" class="tabs__content current">
  <div class="language-js highlighter-rouge"><pre class="highlight"><code><span class="kr">const</span> <span class="nx">os</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'os'</span><span class="p">);</span>


<span class="kr">const</span> <span class="nx">cpus</span> <span class="o">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">cpus</span><span class="p">();</span>
<span class="kr">const</span> <span class="nx">numberOfCpu</span> <span class="o">=</span> <span class="nx">cpus</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>


<span class="kd">let</span> <span class="nx">percentages</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numberOfCpu</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">test</span> <span class="o">=</span> <span class="nx">cpus</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="kr">const</span> <span class="nx">timeboot</span> <span class="o">=</span> <span class="nx">test</span><span class="p">.</span><span class="nx">times</span><span class="p">.</span><span class="nx">user</span> <span class="o">+</span> <span class="nx">test</span><span class="p">.</span><span class="nx">times</span><span class="p">.</span><span class="nx">idle</span> <span class="o">+</span> <span class="nx">test</span><span class="p">.</span><span class="nx">times</span><span class="p">.</span><span class="nx">sys</span> <span class="o">+</span> <span class="nx">test</span><span class="p">.</span><span class="nx">times</span><span class="p">.</span><span class="nx">irq</span> <span class="o">+</span> <span class="nx">test</span><span class="p">.</span><span class="nx">times</span><span class="p">.</span><span class="nx">nice</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">usagetime</span> <span class="o">=</span> <span class="nx">timeboot</span> <span class="o">-</span> <span class="nx">test</span><span class="p">.</span><span class="nx">times</span><span class="p">.</span><span class="nx">idle</span><span class="p">;</span>
    <span class="nx">percentages</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">usagetime</span> <span class="o">/</span> <span class="p">(</span><span class="nx">timeboot</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numberOfCpu</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">total</span> <span class="o">=</span> <span class="nx">total</span> <span class="o">+</span> <span class="nx">percentages</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'total usage: '</span><span class="p">,</span> <span class="nx">total</span> <span class="o">/</span> <span class="nx">numberOfCpu</span><span class="p">);</span>


<span class="c1">// look for the max</span>
<span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">percentages</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numberOfCpu</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">percentages</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">max</span> <span class="o">=</span> <span class="nx">percentages</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'max usage: '</span><span class="p">,</span> <span class="nx">max</span><span class="p">);</span>
</code></pre>
  </div>
</div>

<div id="tab-install-shell" class="tabs__content">
  <div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="c">#!/bin/bash</span>

<span class="c"># -----------------------------------------------</span>
<span class="c">#</span>
<span class="c"># This script displays the percentage of the avg</span>
<span class="c"># cpu usage and the percentage of usage of the</span>
<span class="c"># cpu that is used the most.</span>
<span class="c"># The percentages will be displayed on the row of</span>
<span class="c"># of number, from 1 (less than 10%) to 9 (100%)</span>
<span class="c">#</span>
<span class="c"># -----------------------------------------------</span>



<span class="c"># functions</span>
<span class="c"># ----------</span>

<span class="c"># this function is used to check if there are any errors while sending the signals</span>
<span class="c"># this function takes 1 argument: 1. the result of the "curl" command</span>
check<span class="o">()</span> <span class="o">{</span>
  <span class="c"># a result different from 0 means an error</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$1</span> !<span class="o">=</span> 0 <span class="o">]</span>; <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"ERROR while sending signal"</span>
    <span class="nb">echo</span> <span class="s2">"Make sure that the public api is enabled or that the q-desktop application is running"</span>
    <span class="nb">exit </span>1
  <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># this function is used to initialize the arrays</span>
<span class="c"># this function takes 0 argument</span>
initializeArray<span class="o">()</span> <span class="o">{</span>
  <span class="nv">i</span><span class="o">=</span>0
  <span class="c"># we instenciate the arrays and set their values to 0</span>
  <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -lt <span class="nv">$numberOfCpus</span> <span class="o">]</span>; <span class="k">do
      </span>PREV_TOTALS[<span class="nv">$i</span><span class="o">]=</span>0
      PREV_IDLES[<span class="nv">$i</span><span class="o">]=</span>0
      PERCENTAGES[<span class="nv">$i</span><span class="o">]=</span>0
      <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
  <span class="k">done</span>
  <span class="c"># this array is used to make sure that we don't send signal to keys that haven't changed status</span>
  <span class="c"># since there are 10 keys, we make it an array of length equal to ten</span>
  <span class="c"># and to initialize it we say that no key is switched on (which is true since no key is switched on since the loop has not started yet)</span>
  <span class="k">for </span>number <span class="k">in</span> <span class="o">{</span>0..9<span class="o">}</span>; <span class="k">do
    </span>ALREADYLIT[<span class="nv">$number</span><span class="o">]=</span>0
  <span class="k">done</span>
<span class="o">}</span>

<span class="c"># this function is used to get the infos about the cpu</span>
<span class="c"># this function takes 1 argument: 1. the number of the cpu that we need to get the scores for</span>
getCpuScores<span class="o">()</span> <span class="o">{</span>
    <span class="nv">CPU</span><span class="o">=(</span><span class="sb">`</span>cat /proc/stat | grep ^cpu<span class="nv">$1</span><span class="sb">`</span><span class="o">)</span>
<span class="o">}</span>

<span class="c"># this function is used to get the percentage of utilization of a all the cpus</span>
<span class="c"># the calculation was found on the internet</span>
<span class="c"># this function takes 0 argument</span>
getCpusPercentage<span class="o">()</span> <span class="o">{</span>
  <span class="c"># first we get the datas needed for the computation of the percentage of each cpu</span>
    <span class="nv">CPUS</span><span class="o">=(</span><span class="sb">`</span>cat /proc/stat | grep <span class="s1">'^cpu[0-9]'</span><span class="sb">`</span><span class="o">)</span>
    <span class="c"># $lengthArray correspond to the length of the array get by cat /proc/stat | grep '^cpu[0-9]'</span>
    <span class="nb">local </span><span class="nv">limit</span><span class="o">=</span><span class="nv">$lengthArray</span>
    <span class="nb">local </span><span class="nv">i</span><span class="o">=</span>0
    <span class="c"># we go through every cpu (the cpus are at every 11*index e.g : cpu0 is at 0 and cpu1 is at 11)</span>
    <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -lt <span class="nv">$limit</span> <span class="o">]</span>; <span class="k">do
      </span><span class="nb">local </span><span class="nv">total</span><span class="o">=</span>0
      <span class="nb">local </span><span class="nv">idle</span><span class="o">=</span><span class="k">${</span><span class="nv">CPUS</span><span class="p">[</span><span class="nv">$i</span><span class="p">+4]</span><span class="k">}</span>
      <span class="nv">j</span><span class="o">=</span>1
      <span class="c"># we go through the data needed for every cpu</span>
      <span class="k">while</span> <span class="o">[</span> <span class="nv">$j</span> -le 5 <span class="o">]</span>; <span class="k">do
        </span><span class="nv">total</span><span class="o">=</span><span class="k">$((</span>total+<span class="k">${</span><span class="nv">CPUS</span><span class="p">[</span><span class="nv">$i</span><span class="p">+</span><span class="nv">$j</span><span class="p">]</span><span class="k">}))</span>
        <span class="nv">j</span><span class="o">=</span><span class="k">$((</span>j+1<span class="k">))</span>
      <span class="k">done
      </span><span class="nb">local </span><span class="nv">cpu</span><span class="o">=</span><span class="k">$((</span>i/11<span class="k">))</span>
      <span class="c"># we do the computation, the calculation can be found on the internet</span>
      <span class="nb">let</span> <span class="s2">"diff_idle=</span><span class="nv">$idle</span><span class="s2">-</span><span class="k">${</span><span class="nv">PREV_IDLES</span><span class="p">[</span><span class="nv">$cpu</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span>
      <span class="nb">let</span> <span class="s2">"diff_total=</span><span class="nv">$total</span><span class="s2">-</span><span class="k">${</span><span class="nv">PREV_TOTALS</span><span class="p">[</span><span class="nv">$cpu</span><span class="p">]</span><span class="k">}</span><span class="s2">"</span>
      <span class="nb">let</span> <span class="s2">"diff_usage=(1000*(</span><span class="nv">$diff_total</span><span class="s2">-</span><span class="nv">$diff_idle</span><span class="s2">)/</span><span class="nv">$diff_total</span><span class="s2">+5)/10"</span>
      <span class="c"># we save the percentages and the values in arrays</span>
      PERCENTAGES[<span class="nv">$cpu</span><span class="o">]=</span><span class="nv">$diff_usage</span>
      PREV_IDLES[<span class="nv">$cpu</span><span class="o">]=</span><span class="nv">$idle</span>
      PREV_TOTALS[<span class="nv">$cpu</span><span class="o">]=</span><span class="nv">$total</span>
      <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+11<span class="k">))</span>
    <span class="k">done</span>
<span class="o">}</span>

<span class="c"># this function is used to get the range of the keys to colorize according to the percentage</span>
<span class="c"># this function takes 1 argument: 1. the percentage of utilization of a cpu</span>
getRangeOfKey<span class="o">()</span> <span class="o">{</span>
  <span class="c"># we display the percentage between the key_0 and key_9</span>
  <span class="nb">local </span><span class="nv">maxKey</span><span class="o">=</span><span class="k">$((</span><span class="nv">$1</span><span class="o">*</span><span class="m">10</span><span class="o">/</span><span class="m">100</span><span class="k">))</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$maxKey</span> <span class="o">==</span> 0 <span class="o">]</span>; <span class="k">then
    </span><span class="nv">maxKey</span><span class="o">=</span>1
  <span class="k">fi
  return</span> <span class="nv">$maxKey</span>
<span class="o">}</span>


<span class="c"># this function is used to send a signal to the public api</span>
<span class="c"># this function takes 3 argument: 1. the key to which we want to send a signal</span>
<span class="c">#                                 2. the color we want to send</span>
<span class="c">#                                 3. the effect we want to send</span>
sendSignal<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">key</span><span class="o">=</span><span class="nv">$1</span>
  <span class="nb">local </span><span class="nv">color</span><span class="o">=</span><span class="nv">$2</span>
  <span class="nb">local </span><span class="nv">effect</span><span class="o">=</span><span class="nv">$3</span>
  <span class="nb">local </span><span class="nv">name</span><span class="o">=</span><span class="nv">$4</span>
  <span class="nb">local </span><span class="nv">message</span><span class="o">=</span><span class="nv">$5</span>
  curl -X POST --header <span class="s1">'Content-Type: application/json'</span> --header <span class="s1">'Accept: application/json'</span> -d <span class="s1">'{
  "pid": "'</span><span class="nv">$PID</span><span class="s1">'",
  "zoneId": "'</span><span class="nv">$key</span><span class="s1">'",
  "color": "'</span><span class="nv">$color</span><span class="s1">'",
  "effect": "'</span><span class="nv">$effect</span><span class="s1">'",
  "name": "",
  "message": "",
  "shouldNotify": false,
  "isRead": false
  }'</span> <span class="nv">$URL</span> &amp;&gt; /dev/null <span class="c"># this is to make sure that curl doesn't display anything</span>
  check <span class="nv">$?</span>
<span class="o">}</span>

<span class="c"># this function is used to switch off all the keys at the beginnig</span>
switchOffAllTheKeys<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">i</span><span class="o">=</span>0
  <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -le 9 <span class="o">]</span>; <span class="k">do
    </span>sendSignal <span class="s2">"KEY_</span><span class="nv">$i</span><span class="s2">"</span> <span class="s2">""</span> <span class="s2">"NONE"</span> <span class="s2">"cpu-meter"</span> <span class="s2">"Stopping processus </span><span class="nv">$$</span><span class="s2">: cpu-meter"</span>
    <span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
  <span class="k">done</span>
<span class="o">}</span>

<span class="c"># this function is used to switch off signals (usually switch off signals that don't need to be switched on)</span>
<span class="c"># this function takes 1 argument: 1. the key for which we are sending the signal</span>
sendSwitchOffSignal<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">key</span><span class="o">=</span><span class="nv">$1</span>
    <span class="c"># we send a signal with black color and with the property effet: none, in order to switch off the key</span>
  sendSignal <span class="s2">"KEY_</span><span class="nv">$key</span><span class="s2">"</span> <span class="s2">""</span> <span class="s2">"NONE"</span> <span class="s2">""</span> <span class="s2">""</span>
  ALREADYLIT[<span class="nv">$key</span><span class="o">]=</span>0
<span class="o">}</span>

<span class="c"># this function is used to send signals to the key</span>
<span class="c"># this functions takes 1 argument: 1. the key that needs to be switched on</span>
sendSignalToInBetweenKey<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">key</span><span class="o">=</span><span class="nv">$1</span>
  <span class="c"># here it means that we display a green color for the max cpu</span>
  sendSignal <span class="s2">"KEY_</span><span class="nv">$key</span><span class="s2">"</span> <span class="s2">"#0fff77"</span> <span class="s2">"SET_COLOR"</span> <span class="s2">""</span> <span class="s2">""</span>
  <span class="c"># here we check for the response of the curl</span>
  check <span class="nv">$?</span>
  ALREADYLIT[<span class="nv">$key</span><span class="o">]=</span>1
<span class="o">}</span>

<span class="c"># this function is used to send signals to the end key (blue or yellow) to differentiate between avg cpu and max cpu</span>
<span class="c"># this function takes 2 arguments: 1. the key that needs to receive the signal</span>
<span class="c">#                                  2. for which cpu we are currently sending a signal for the upperKey (either 0: cpu avg or 1: cpu max)</span>
sendSignalsToEndKey<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">key</span><span class="o">=</span><span class="nv">$1</span>
  <span class="nb">local </span><span class="nv">from</span><span class="o">=</span><span class="nv">$2</span>
  <span class="c"># we test to see if the function is called to display the max cpu or the avg cpu</span>
  <span class="c"># 0: avg cpu</span>
  <span class="c"># 1: max cpu</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$from</span> -eq 0 <span class="o">]</span>; <span class="k">then</span>
    <span class="c"># here it means that it is to display the avg cpu, we display the end key in blue</span>
    sendSignal <span class="s2">"KEY_</span><span class="nv">$key</span><span class="s2">"</span> <span class="s2">"#0fa7ff"</span> <span class="s2">"SET_COLOR"</span> <span class="s2">""</span> <span class="s2">""</span>
    ALREADYLIT[<span class="nv">$key</span><span class="o">]=</span>2
  <span class="k">else</span>
    <span class="c"># here it means that it is to display the max cpu, we display the end key in green</span>
    sendSignal <span class="s2">"KEY_</span><span class="nv">$key</span><span class="s2">"</span> <span class="s2">"#0fff77"</span> <span class="s2">"SET_COLOR"</span> <span class="s2">""</span> <span class="s2">""</span>
    check <span class="nv">$?</span>
    ALREADYLIT[<span class="nv">$key</span><span class="o">]=</span>1
  <span class="k">fi</span>

<span class="o">}</span>

<span class="c"># this function is used to colorize the number row on the keyboard</span>
<span class="c"># this function takes 3 arguments: 1. the upper key limit (for example: if you need to switch on keys 1,2 and 3, maxKey will be 3)</span>
<span class="c">#                                  2. the url were to send the signal</span>
<span class="c">#                                  3. for which cpu we are currently colorizing the keys (either 0: cpu avg or 1: cpu max)</span>
colorizeKeys<span class="o">()</span> <span class="o">{</span>
  <span class="c"># first we get the maxkey</span>
  <span class="nb">local </span><span class="nv">maxKey</span><span class="o">=</span><span class="nv">$1</span>
  <span class="c"># this is to know if the function was called to display avg cpu or max cpu</span>
  <span class="nb">local </span><span class="nv">from</span><span class="o">=</span><span class="nv">$3</span>
  <span class="c"># if the percentage is close to zero, we still display the first key</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$maxKey</span> -eq 0 <span class="o">]</span>; <span class="k">then
    </span><span class="nv">maxKey</span><span class="o">=</span>1
  <span class="k">fi

  </span><span class="nb">local </span><span class="nv">i</span><span class="o">=</span>1
  <span class="nb">local </span><span class="nv">url</span><span class="o">=</span><span class="nv">$2</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$from</span> !<span class="o">=</span> 0 <span class="o">]</span>; <span class="k">then</span>
    <span class="c"># for each key in between the first key and the max key, we set a color  </span>
    <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -lt <span class="nv">$maxKey</span> <span class="o">]</span>; <span class="k">do</span>
      <span class="c"># this test is used to get rid of the blinking problem of the avg cpu color</span>
      <span class="k">if</span> <span class="o">[</span> <span class="nv">$i</span> !<span class="o">=</span> <span class="nv">$MAX_KEY_AVG</span> <span class="o">]</span>; <span class="k">then
        </span>getSwitchedState <span class="nv">$i</span>
        <span class="c"># we check if the key is not switched on, if it is not, then we switch on key</span>
        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> <span class="o">==</span> 0 <span class="o">||</span> <span class="nv">$?</span> <span class="o">==</span> 2 <span class="o">]]</span>; <span class="k">then
            </span>sendSignalToInBetweenKey <span class="nv">$i</span>
        <span class="k">fi
      fi
      </span><span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
    <span class="k">done
  fi</span>

  <span class="c"># if the maxKey is 10, percentage equals to 100, we display the 0 key as the max key</span>
  <span class="c"># (since it is the last key on the row)</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$maxKey</span> -eq 10 <span class="o">]</span>; <span class="k">then
    </span><span class="nv">maxKey</span><span class="o">=</span>0
  <span class="k">fi</span>
  <span class="c"># this is to make sure that we are lighting up the avg cpu keys</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="nv">$from</span> <span class="o">==</span> 0 <span class="o">]]</span>; <span class="k">then</span>
    <span class="c"># finally we colorize the maxkey</span>
    getSwitchedState <span class="nv">$maxKey</span>
    <span class="c"># we check if the key is not switched on, if it is not, then we switch on key</span>
    <span class="c"># the one means that the key represents a max cpu key, and since we gave priority to the avg cpu keys,</span>
    <span class="c"># we give authorization to the avg cpu key to overwrite the color of a max cpu key</span>
    <span class="c"># and this is what we are doing here</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> !<span class="o">=</span> 2 <span class="o">]]</span>; <span class="k">then
      </span>sendSignalsToEndKey <span class="nv">$maxKey</span> <span class="nv">$from</span>
    <span class="k">fi
  else</span>
  <span class="c"># the else makes sure that we a lighting up max cpu keys</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$maxKey</span> !<span class="o">=</span> <span class="nv">$MAX_KEY_AVG</span> <span class="o">]</span>; <span class="k">then
      </span>getSwitchedState <span class="nv">$maxKey</span>
      <span class="c">#</span>
      <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> !<span class="o">=</span> 1 <span class="o">]]</span>; <span class="k">then
        </span>sendSignalsToEndKey <span class="nv">$maxKey</span> <span class="nv">$from</span>
      <span class="k">fi
    fi
  fi</span>
<span class="o">}</span>

<span class="c"># this function is used to switch off the keys that we don't need</span>
<span class="c"># this function takes 1 argument: 1. the lower key limit (for example: if you need to switch off keys 8, 9 and 0 maxKey will be 7)</span>
switchOffUnnecessaryKeys<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">maxKey</span><span class="o">=</span><span class="k">$((</span><span class="nv">$1</span><span class="o">+</span><span class="m">1</span><span class="k">))</span>
  <span class="nb">local </span><span class="nv">key</span><span class="o">=</span><span class="nv">$maxKey</span>
  <span class="k">while</span> <span class="o">[</span> <span class="nv">$key</span> -le 9 <span class="o">]</span>; <span class="k">do
    </span>getSwitchedState <span class="nv">$key</span>
    <span class="c"># we check if the key is switched on, if it is, then we switch off key</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> !<span class="o">=</span> 0 <span class="o">]]</span>; <span class="k">then
        </span>sendSwitchOffSignal <span class="nv">$key</span>
    <span class="k">fi
    </span><span class="nv">key</span><span class="o">=</span><span class="k">$((</span>key+1<span class="k">))</span>
  <span class="k">done</span>
  <span class="c"># it means that the key 0 (the tenth key on the row) is on, so we don't need to switch it off</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$maxKey</span> !<span class="o">=</span> 11 <span class="o">]</span>; <span class="k">then
    </span><span class="nv">key</span><span class="o">=</span>0
    <span class="c"># if the 0 key is not switched on by the actual loop we switch it off</span>

    sendSwitchOffSignal <span class="nv">$key</span>
  <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># this function is used to know if a key is switched on or not</span>
<span class="c"># this function takes 1 argument: 1. the key that we want to check if it is switched on or not</span>
<span class="c"># this function returns a integer : - 0 it means that the key is switched off</span>
<span class="c">#                                   - 1 it means that the key is switched on and represents max cpu</span>
<span class="c">#                                   - 2 it means that the key is switched on and represents avg cpu</span>
getSwitchedState<span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> <span class="k">${</span><span class="nv">ALREADYLIT</span><span class="p">[</span><span class="nv">$1</span><span class="p">]</span><span class="k">}</span> <span class="o">==</span> 1 <span class="o">]</span>; <span class="k">then
        return </span>1
    <span class="k">elif</span> <span class="o">[</span> <span class="k">${</span><span class="nv">ALREADYLIT</span><span class="p">[</span><span class="nv">$1</span><span class="p">]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">]</span>; <span class="k">then
        return </span>0
    <span class="k">else</span>
    <span class="c"># this means that this was the previous placement of the avg percentage key</span>
        <span class="k">return </span>2
    <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># this function is used to send a signal to a key for the animation</span>
<span class="c"># this function takes 1 argument: 1. the key that we want to switch on</span>
sendSignalForAnim<span class="o">()</span> <span class="o">{</span>
  <span class="nv">key</span><span class="o">=</span><span class="nv">$1</span>
  sendSignal <span class="s2">"</span><span class="nv">$key</span><span class="s2">"</span> <span class="s2">"#F00"</span> <span class="s2">"BLINK"</span> <span class="s2">"cpu-meter"</span> <span class="s2">"Starting the processus </span><span class="nv">$$</span><span class="s2">: cpu-meter"</span>
<span class="o">}</span>

<span class="c"># this function is used to switch off keys after the animation</span>
<span class="c"># this function takes 1 argument: 1. the key that we want to switch off</span>
switchOffKeyForAnim <span class="o">()</span> <span class="o">{</span>
  <span class="nv">key</span><span class="o">=</span><span class="nv">$1</span>
  sendSignal <span class="s2">"</span><span class="nv">$key</span><span class="s2">"</span> <span class="s2">"#000"</span> <span class="s2">"NONE"</span> <span class="s2">""</span> <span class="s2">""</span>
<span class="o">}</span>

<span class="c"># this function is used to display a little animation, this displays a blinking red "CPU" on the keyboard</span>
<span class="c"># this function takes 0 argument</span>
displayAnimation<span class="o">()</span> <span class="o">{</span>
  <span class="c"># writing the C</span>
  sendSignalForAnim 72
  sendSignalForAnim 76
  sendSignalForAnim 75
  sendSignalForAnim 99
  sendSignalForAnim 123
  sendSignalForAnim 124
  <span class="c"># writing the P</span>
  sendSignalForAnim 78
  sendSignalForAnim 79
  sendSignalForAnim 80
  sendSignalForAnim 103
  sendSignalForAnim 104
  sendSignalForAnim 105
  sendSignalForAnim 127
  <span class="c"># writing the U</span>
  sendSignalForAnim 82
  sendSignalForAnim 85
  sendSignalForAnim 107
  sendSignalForAnim 109
  sendSignalForAnim 131
  sendSignalForAnim 132
  sendSignalForAnim 71

  sleep 3

  <span class="c"># switching the keys off</span>
  switchOffKeyForAnim 72
  switchOffKeyForAnim 76
  switchOffKeyForAnim 75
  switchOffKeyForAnim 99
  switchOffKeyForAnim 123
  switchOffKeyForAnim 124
  switchOffKeyForAnim 78
  switchOffKeyForAnim 79
  switchOffKeyForAnim 80
  switchOffKeyForAnim 103
  switchOffKeyForAnim 104
  switchOffKeyForAnim 105
  switchOffKeyForAnim 127
  switchOffKeyForAnim 82
  switchOffKeyForAnim 85
  switchOffKeyForAnim 107
  switchOffKeyForAnim 109
  switchOffKeyForAnim 131
  switchOffKeyForAnim 132
  switchOffKeyForAnim 71
<span class="o">}</span>

<span class="c"># MAIN PROGRAM</span>
<span class="c"># ------------</span>

<span class="c"># Initialization</span>
<span class="c"># --------------</span>

<span class="nb">echo</span> <span class="s2">"Starting the processus </span><span class="nv">$$</span><span class="s2">: cpu-meter"</span>

<span class="c"># this is to get the CTRL-C and switch off all the keys when the user exits the script</span>
<span class="nb">trap</span> <span class="s2">"switchOffAllTheKeys; echo ''; echo 'Stopping the processus </span><span class="nv">$$</span><span class="s2">: cpu-meter'"</span> EXIT
<span class="c"># trap "switchOffAllTheKeys"</span>
<span class="c"># we get the requirements to colorize the keyboard</span>

<span class="c"># we get the PID and the URL in order to send the signal to the api</span>
<span class="nv">PORT</span><span class="o">=</span>27301
<span class="nv">PID</span><span class="o">=</span><span class="s2">"DK5QPID"</span> <span class="c"># product ID</span>
<span class="nv">URL</span><span class="o">=</span><span class="s2">"http://localhost:</span><span class="nv">$PORT</span><span class="s2">/api/1.0/signals"</span>

<span class="c"># first we initialize all the needed variables</span>
<span class="c"># prev total is used to calculate the percentage of the avg cpu</span>
<span class="nv">PREV_TOTAL</span><span class="o">=</span>0
<span class="c"># prev idle is used to calculate the percentage of the avg cpu</span>
<span class="nv">PREV_IDLE</span><span class="o">=</span>0
<span class="c"># this is to get the number of cpu</span>
<span class="nv">numberOfCpus</span><span class="o">=(</span><span class="sb">`</span>grep -c ^processor /proc/cpuinfo<span class="sb">`</span><span class="o">)</span>
<span class="nv">lengthArray</span><span class="o">=</span><span class="k">$((</span>numberOfCpus<span class="o">*</span><span class="m">11</span><span class="k">))</span>
<span class="c"># those arrays are used to calculate the percentage of utilization for each cpu</span>
<span class="nv">PREV_TOTALS</span><span class="o">=()</span>
<span class="nv">PREV_IDLES</span><span class="o">=()</span>
<span class="nv">PERCENTAGES</span><span class="o">=()</span>
<span class="nv">ALREADYLIT</span><span class="o">=()</span>

initializeArray
<span class="c"># we display a little animation for the user at the beginning of the script</span>
<span class="c"># displayAnimation</span>
<span class="c"># we switch off all the keys at first to make sure that there are no "noise" color on the row of key</span>
<span class="c"># switchOffAllTheKeys</span>

<span class="c"># MAIN LOOP</span>
<span class="c"># ---------</span>

<span class="k">while </span><span class="nb">true</span>; <span class="k">do</span>

<span class="c"># GET THE MEAN USAGE OF THE CPU</span>
<span class="c"># -----------------------------</span>
  <span class="c"># we get the mean of the cpu usage</span>
  <span class="nv">CPU</span><span class="o">=(</span><span class="sb">`</span>cat /proc/stat | grep <span class="s1">'^cpu '</span><span class="sb">`</span><span class="o">)</span> <span class="c"># Get the total CPU statistics.</span>
  <span class="nb">unset </span>CPU[0]                          <span class="c"># Discard the "cpu" prefix.</span>
  <span class="nv">IDLE</span><span class="o">=</span><span class="k">${</span><span class="nv">CPU</span><span class="p">[4]</span><span class="k">}</span>
  <span class="c"># Calculate the total CPU time.</span>
  <span class="nv">TOTAL</span><span class="o">=</span>0
  <span class="k">for </span>VALUE <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">CPU</span><span class="p">[@]</span>:0:4<span class="k">}</span><span class="s2">"</span>; <span class="k">do
    </span><span class="nb">let</span> <span class="s2">"TOTAL=</span><span class="nv">$TOTAL</span><span class="s2">+</span><span class="nv">$VALUE</span><span class="s2">"</span>
  <span class="k">done</span>

  <span class="c"># Calculate the CPU usage since we last checked.</span>
  <span class="nb">let</span> <span class="s2">"DIFF_IDLE=</span><span class="nv">$IDLE</span><span class="s2">-</span><span class="nv">$PREV_IDLE</span><span class="s2">"</span>
  <span class="nb">let</span> <span class="s2">"DIFF_TOTAL=</span><span class="nv">$TOTAL</span><span class="s2">-</span><span class="nv">$PREV_TOTAL</span><span class="s2">"</span>
  <span class="c"># diff_usage is the percentage</span>
  <span class="nb">let</span> <span class="s2">"PERCENTAGE_AVG=(1000*(</span><span class="nv">$DIFF_TOTAL</span><span class="s2">-</span><span class="nv">$DIFF_IDLE</span><span class="s2">)/</span><span class="nv">$DIFF_TOTAL</span><span class="s2">+5)/10"</span>

  <span class="c"># Remember the total and idle CPU times for the next check.</span>
  <span class="nv">PREV_TOTAL</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TOTAL</span><span class="s2">"</span>
  <span class="nv">PREV_IDLE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$IDLE</span><span class="s2">"</span>

<span class="c"># GET THE MAX USAGE BETWEEN ALL THE CPUS</span>
<span class="c"># --------------------------------------</span>
  <span class="c"># first we get the percentage of utilization for each cpu</span>
  getCpusPercentage

  <span class="c"># then we get the max</span>
  <span class="nv">MAX</span><span class="o">=</span><span class="k">${</span><span class="nv">PERCENTAGES</span><span class="p">[0]</span><span class="k">}</span>
  <span class="nv">i</span><span class="o">=</span>0
  <span class="c"># this loop is used to get the max, it is a simple search for the max algorithm</span>
  <span class="k">while</span> <span class="o">[</span> <span class="nv">$i</span> -lt <span class="nv">$numberOfCpus</span> <span class="o">]</span>; <span class="k">do
    if</span> <span class="o">[</span> <span class="k">${</span><span class="nv">PERCENTAGES</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span> -gt <span class="nv">$MAX</span> <span class="o">]</span>; <span class="k">then
        </span><span class="nv">MAX</span><span class="o">=</span><span class="k">${</span><span class="nv">PERCENTAGES</span><span class="p">[</span><span class="nv">$i</span><span class="p">]</span><span class="k">}</span>
    <span class="k">fi
    </span><span class="nv">i</span><span class="o">=</span><span class="k">$((</span>i+1<span class="k">))</span>
  <span class="k">done</span>

  <span class="c"># we get the range of key that need to be switched on for the avg cpu</span>
  getRangeOfKey <span class="nv">$PERCENTAGE_AVG</span>
  <span class="nv">MAX_KEY_AVG</span><span class="o">=</span><span class="nv">$?</span>
  <span class="c"># we the range of key that need to be switched on for the max cpu</span>
  getRangeOfKey <span class="nv">$MAX</span>
  <span class="nv">MAX_KEY_MAX</span><span class="o">=</span><span class="nv">$?</span>

  <span class="c"># we first colorized the keys for the max cpu because we will colorized the avg cpu above the color of the max cpu</span>
  <span class="c"># since the max cpu will always be higher or equal to the avg cpu</span>
  colorizeKeys <span class="nv">$MAX_KEY_MAX</span> <span class="nv">$URL</span> 1


  <span class="c"># then we colorize the keys for the avg cpu</span>
  colorizeKeys <span class="nv">$MAX_KEY_AVG</span> <span class="nv">$URL</span> 0
  <span class="c"># and we finish by switching off unecessary key</span>
  switchOffUnnecessaryKeys <span class="nv">$MAX_KEY_MAX</span>
  <span class="c"># Wait before checking again.</span>

  <span class="nb">echo</span> -ne <span class="s2">"</span><span class="se">\r</span><span class="s2"> avg cpu percentage: </span><span class="nv">$PERCENTAGE_AVG</span><span class="s2">%     max cpu percentage: </span><span class="nv">$MAX</span><span class="s2">%   </span><span class="se">\b\b</span><span class="s2">"</span>

  <span class="c"># echo "${ALREADYLIT[@]}"</span>

<span class="c">#   echo -ne "\r $MAX_KEY_MAX  \b\b"</span>
  sleep 1
<span class="k">done</span>
</code></pre>
  </div>
</div>

</article>

          </div>
        </div>

        

      </div> <!-- /.row -->
    </div> <!-- /.container -->

    <footer class="site-footer">
  <div class="container-fluid">
    <div class="row">
      <div class="col-sm-12">
        <div class="logo">
          <img src="/daskeyboard.github.io/images/icon.png" alt="Das Keyboard Logo" width="70" height="90">
        </div>
          <p class="site-footer__link-list">
            <a href="https://www.daskeyboard.com">www.daskeyboard.com</a> &bull;
            <a href="https://twitter.com/daskeyboard">Twitter</a> &bull;
            <a href="https://github.com/metadot">Github</a> &bull;
            <a href="https://qforum.daskeyboard.com/">Forum</a>
          </p>

          <p class="licenses">
            Except as otherwise noted,
            this work is licensed under a
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative
            Commons Attribution 4.0 International License</a>,
            and code samples are licensed under the BSD License.
          </p>
      </div>
    </div>
  </div>

</footer>


    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="/daskeyboard.github.io/js/js-bootstrap/bootstrap.js"></script>
    <script src="/daskeyboard.github.io/js/sidebar_toggle.js"></script>
    <script src="/daskeyboard.github.io/js/prism.js"></script>
    <script src="/daskeyboard.github.io/js/tabs.js"></script>
    <script src="/daskeyboard.github.io/js/credentials.js"></script>
    
    
    <script async="" defer="" src="//survey.g.doubleclick.net/async_survey?site=at3ul57xpub2vk3oxt2ytw365i"></script>
  </body>
</html>
